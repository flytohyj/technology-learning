# **代理模式**
## 问题
- 1、仿JDK动态代理实现原理，自己手写一遍。
- 2、思考：为什么JDK动态代理中要求目标类实现的接口数量不能超过65535个？
- 3、结合自身的业务场景用代理模式进行重构。

## 1. 定义
- 代理模式（Proxy Pattern）为其他对象提供一种代理，以控制对这个对象的访问。
- 代理对象在客服端和目标对象之间起到中介作用，代理模式属于结构型设计模式。
- 使用代理模式主要有两个目的：一保护目标对象，二增强目标对象。
- 代理模式优点：
代理模式能将代理对象与真实被调用的目标对象分离。
一定程度上降低了系统的耦合程度，易于扩展。
代理可以起到保护目标对象的作用。
增强目标对象的职责

- 代理模式 缺点：
代理模式会造成系统设计中类的数目增加
在客户端和目标对象之间增加了一个代理对象，会造成请求处理速度变慢。
增加了系统的复杂度。


## 2. 适用场景
- 租房中介、售票黄牛、婚介、经纪人、快递,出租车司机、事务代理、非侵入式日志监听等。
## 3. 分类
- 静态代理：显式声明被代理对象
- 动态代理：动态配置和替换被代理对象
- 动态代理实现原理：
1、拿到被代理类的引用，并且获取它的所有的接口（反射获取）。
2、JDK Proxy类重新生成一个新的类，实现了被代理类所有接口的方法。
3、动态生成Java代码，把增强逻辑加入到新生成代码中。
4、编译生成新的Java代码的class文件。
5、加载并重新运行新的class，得到类就是全新类。
- CGLib动态代理
1、无法代理final修饰的方法。

## 4. CGLib和JDK动态代理对比
- 1.JDK动态代理是实现了被代理对象的接口，CGLib是继承了被代理对象。
- 2.JDK和CGLib都是在运行期生成字节码，JDK是直接写Class字节码，CGLib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。
- 3.JDK调用代理方法，是通过反射机制调用，CGLib是通过FastClass机制直接调用方法，CGLib执行效率更高。
## 5.问题：
2、思考：为什么JDK动态代理中要求目标类实现的接口数量不能超过65535个？


Class文件是一组以8字节为基础单位的二进制流
各个数据项目严格按照顺序紧凑排列在class文件中
中间没有任何分隔符，这使得class文件中存储的内容几乎是全部程序运行的程序
Java虚拟机规范规定，Class文件格式采用类似C语言结构体的伪结构来存储数据，这种结构只有两种数据类型：无符号数和表
接口索引计数器(interfaces_count)，占2字节

参考第一句话：class文件是一组8字节为基础的二进制流，interface_count占2字节。也就是16.00000000,00000000 所以，证明
interface_count的数量最多是2^16次方 最大值=65535
这是在JVM的层面上决定了它的数量最多是65535
且在java源码中也可以看到

if (interfaces.length > 65535) {
            throw new IllegalArgumentException("interface limit exceeded");
        }
直接做了65535的长度的校验，所以，JDK的动态代理要求，目标类实现的接口数量不能超过65535


